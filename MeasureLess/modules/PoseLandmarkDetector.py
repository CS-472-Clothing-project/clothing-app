import numpy as np
import mediapipe as mp
import logging

from mediapipe import solutions
from mediapipe.framework.formats import landmark_pb2
from mediapipe.tasks import python
from mediapipe.tasks.python import vision

# Considering rolling this into another class. Might be more effective
# to just inherit this or make it a member of the image handler.

# TODO: Rework this constructor to accept the entire object generated by ImageHandler.
class PoseLandmarkDetector:
    def __init__(self, imageObject,  landmarkerMode=2):
        # Setting model path
        if landmarkerMode == 1:
            self.landmarkerPath = 'models/pose_landmarker_lite.task'
        elif landmarkerMode == 2:
            self.landmarkerPath = 'models/pose_landmarker_full.task'
        elif landmarkerMode == 3:
            self.landmarkerPath = 'models/pose_landmarker_heavy.task'
        
            
        # Setting the image object for use through the class (this
        # is one reason why it might work better as an inherited
        # class or method)
        self.imageObject = imageObject.numpy_view()
        
        # Loading the detector object as class member
        # self.loadDetector()
        
        baseOptions = python.BaseOptions(model_asset_path=self.landmarkerPath)
        options = vision.PoseLandmarkerOptions(
            base_options=baseOptions,
            output_segmentation_masks=True)
        self.detector = vision.PoseLandmarker.create_from_options(options)
        self.detectedImage = self.detector.detect(self.imageObject)

        
    # Method for loading the detection model
    # def loadDetector(self):
        
        # # Set the options and load the image detector
        # try:
        #     print("Loading detector with path: ", self.landmarkerPath)
        #     baseOptions = python.BaseOptions(self.landmarkerPath)
        # except: 
        #     print("Error getting base options")
            
        # try:
        #     options = vision.PoseLandmarkerOptions(base_options=baseOptions,
        #                                        output_segmentation_masks=True)
        # except:
        #     print("Error setting options")
        
        # try:
        #     self.detector = vision.PoseLandmarker.create_from_options(options)
        # except:
        #     print("Error loading detector")
        
    # Method for placing the markings on the image and generating the list of landmarks
    def drawLandmarks(self):
        # Using the loaded detector to detect body points
        
        # Load list of detected landmarks and stores it
        self.landmarkList = self.detectedImage.pose_landmarks
        landmarkedImage = np.copy(self.imageObject)
        
        # Goes through all detected points to draw onto landmarkedImage
        for i in range(len(self.landmarkList)):
            landmarks = self.landmarkList[i]
            
            # Creates an empty NormalizedLandmarkList object
            landmarksProto = landmark_pb2.NormalizedLandmarkList()
            
            # Extends the list for each point in the list by using the landmark_pb2 method to normalize
            # the landmark from the resolution of the provided image
            # NOTE: This might pose a problem when using the height to calculate the lengths between 
            # points. We will need to take this into account when drawing up an algorithm as we
            # will need to normalize the same way
            landmarksProto.landmark.extend([
                landmark_pb2.NormalizedLandmark(x=landmark.x, y=landmark.y, z=landmark.z) for landmark in landmarks
            ])
            
            # Draw landmarks onto landmarkedImage
            try:
                solutions.drawing_utils.draw_landmarks(
                    landmarkedImage,
                    landmarksProto,
                    solutions.pose.POSE_CONNECTIONS,
                    solutions.drawing_styles.get_default_pose_landmarks_style())
            except IndexError:
                logging.exception("An index error occurred.")
                print("Detected landmarkedImage type: ", type(landmarkedImage))
                print("Detected landmarksProto type: ", type(landmarksProto))
                print("Length of image: ", landmarkedImage.shape)
            except:
                print("Something else went wrong with draw_landmarks")
            
        # Save copy of landmarked image to class instance
        self.landmarkedImage = landmarkedImage
        return landmarkedImage